# Swift Study

### 변수(Variables)

- var a = 3 // ← a 라는 데이터 상자에 3이라는 값을 저장한다
    
    a = 7
    

a = a + 4       // 11

- 저장한 값을 변경 가능(mutable)

### 상수(Constants)

- let a = 3 ← a 라는 데이터 상자에 3이라는 값을 저장한다
    
    a = 7  ← error
    

- 저장한 값을 변경 불가능(immutable)

### Type ⭐

| 키워드(약속어) | 타입 설명 | 예시 |
| --- | --- | --- |
| Int(⭐) | 정수, 8바이트 (64 바이트 환경) | 5, 7, -123, 0 |
| Float | 부동소수(6자리), 4바이트(32비트) | 3.14, -14.187 |
| Double(⭐) | 부동소수(15자리), 8바이트(64비트) | 3.14, -14.187 |
| Character | 하나의문자, 쌍따옴표 사용(””) | “A”, “a”, “한”, “ “ |
| String(⭐) | 문자열, 쌍따옴표 사용(””) | “안녕하세요”, “스티브 잡스”, “” |
| Bool(⭐) | 참/거짓 | true, false |
| 기타 | Uint, Uint64, Int32 … |  |

*Swift에서 타입에 관한 키워드는 모두 대문자로 시작

---

### 타입 안정성

→ Swift는 다른 타입끼리 계산할 수 없다.

let num5 = 1

let num6 = 1.5

num5 + num6 =            —— error

Int + Double = impossible

| 변수와 타입 문법 | 예시 |
| --- | --- |
| 타입 주석 | var name: String = 홍길동 |
| 타입 추론 | var name = “홍길동” |
| 타입 안정성 | var number = 12 (Int)
number = 1.5 (Double) 할당 불가  |

타입 변환

String 타입  “123” → 타입변환 정상적 변환  Int(”123”) → Int 타입 123

String 타입 “안녕” → 타입변환 비정상적 변환 Int(”안녕”)  → nil  값이 없음을 나타내는 키워드

Double 타입 “123.45” → 타입변환 Int(123.45) → Int 타입 123, 소수점 버림

*데이터가 변환이 되지 않거나, 데이터가 유실 될 수 있다는 점을 주의해서 사용해야 함

### 타입 앨리어스(Type Alias)

별칭 붙이기

ex) typealias Name = String

→ 이후 Name 으로 타입 설정 가능

- 가독성을 높히기 위한 기능

### 경고와 오류(에러)

⚠️warning

코드가 잘못된 것은 아님, 혹시나 더 나은 방법을 제안

예)변수(var)로 선언한 것이 바뀌는 일이 없을때 상수(let)로 바꿀 것을 제안

❗error

컴파일 오류

코드가 잘못되었음을 알려줌 → 반드시 수정해야만 함

(컴파일러가 추정하기에 왜 오류가 나는지 알려줌)

### 리터럴(Literals)

- 코드에서 고정된 값으로 표현되는 문자(데이터) 그 자체(Int / Double / String / Bool 리터럴 등)

### 식별자(Identifier)

- 변수, 상수, 함수 사용자 정의 타입의 이름
    - var name1  =  “전지현”
    - let name2 = “임꺽정”

### 토큰(Token)

- 코드의 가장 작은 단위 : 코드에서 더이상 쪼갤 수 없는 최소의 단위 (식별자, 키워드, 구두점, 연산자, 리터럴)

### 표현식(Expression)

- 값, 변수, 연산자의 조합으로 하나의 결과값으로 평가되는 코드 단위
    - 하나의 값이 나오는 코드
        - var n = 5 //문장
        - 17 // 17
        - n // 5
        - n + 7 // 12
        - n < 5 // false
        

### 문장(Statement)

- 문장 또는 구문 : 특정작업을 실행하는 코드 단위
    - 토큰(키워드) + 표현식(값) ===> 문장(작업을 명령)
    

| 개념 | 정의 | 예시 |
| --- | --- | --- |
| 키워드 | 약속어, 프로그래밍 언어에서 의미있는 단어로 사용하기로 약속한 단어(다른 용도로 사용 불가) | var, let, if, for, in, as, is, true, nil |
| 리터럴⭐️ | 코드에서 고정된 값으로 표현되는 문자(데이터) 그 자체 | “홍길동” (문자열 리터럴)
7            (Int 리터럴)
3.14       (Double 리터럴) |
| 식별자 | 변수, 상수, 함수, 사용자 정의 타입의 이름 | var name = “홍길동” |
| 토큰 | 코드의 가장 작은(더이상 쪼갤 수 없는) 최소 단위(키워드, 식별자, 구두점, 연산자, 리터럴) | let
, (콤마)
== |
| 표현식⭐️ | 값, 변수, 연산자의 조합으로 하나의 결과값으로 평가되는 코드 단위 | number + 7 |
| 문장⭐️ | 특정 작업을 실행하는 코드 단위 | var name = “홍길동”
print(name) |

## 연산자

1. 단항연산자(Unary Operator) - 단항연산자는 공백없이 반드시 붙여서 사용
    
    예시 +a; -a; !; a…
    
2. 이항연산자(Binary Operator) - 이항연산자는 (일반적으로) 양쪽에 공백 1칸씩 추가해서 사용, 양쪽을 붙여서 사용하는 것도 가능하지만, 비대칭적 사용은 금지
    
    예시 a + b ; a >= b
    
3. 삼항연산자(Ternary Operator) - 삼항연산자에서도 모든 사이에 공백을 한칸씩 추가해서 사용
    
    예시 a ? b : c
    

산술연산자(스위프트에 내장된 기본 산술연산자)

+ , - , * , / , % ( / 몫 구하기 = 정수만 출력 , 모듈로(% → 나머지)의 사용 → Int 일때만 사용)

⭐️모듈로(%)의 이해 ⭐️

- 프로그래밍에서 ‘나머지의 개념’ 이해 반드시 필요

### 복합 할당 연산자

| 정의 | 복합 할당
연산 기호 |
| --- | --- |
| value = value + 10 | value += 10 |
| value = value -5  | value -= 5 |
| value = value * 2 | value *= 2 |
| value = value / 2 | value /= 2 |
| value = value % 2 | value %= 2 |

### 비교연산자

| 연산 기호 | 정의 |
| --- | --- |
| a == b | 같다 |
| a != b | 같지 않다 |
| a > b | 크다 |
| a >= b | 크거나 같다 |
| a < b | 작다 |
| a <= b | 작거나 같다 |

### 논리 연산자

| 연산 기호⭐️ | 정의 |
| --- | --- |
| !  | not, 반대 값 출력 |
| && | and, 그리고 |
| || | or, 또는 |

- 연산의 우선순위 (괄호를 적절히 사용하면 됨)
1. * / %       곱하기/나누기
2. + / -         더하기/빼기
3. 비교
4. && ||
5. 삼항
6. 할당

### 접근연산자

- 접근연산자 (.)점 → 하위 개념으로 접근한다

### 프로그래밍의 기본 원리

모든 프로그래밍은 아래의 세가지 논리로 이루어 진다.

1) 순차

2) 조건  + 데이터

3) 반복

1. 순차의 개념 - 개발자가 정한 규칙에 따라 순차적으로(차례대로) 실행한다.
2. 조건문 (if문)
    
    -참(true) 또는 거짓(false)의 특정 조건에 따라 특정 코드만 실행하게 할 수 있는 문장
    
    -해당 조건을 만족한다면 {}중괄호 안의 코드를 실행한다
    
    ex) var number = 10
    
    1) if number >= 10 {
    
    print(”옳다”)
    
    }
    
    2) if number >= 10 {
    
    print(”옳다”)
    
    }else{
    
    print(”옳지 않다”)
    
    }
    
    if condition {
    
    code
    
    }else{
    
    code
    
    }
    
    if condition1 {
    
    code
    
    }else if condition2{
    
    code
    
    }else{
    
    code
    
    }
    
    *if문 사용시
    
    1) if문에서 논리적인 구조 및 조건의 순서 중요
    
    2) 조건을 &&(and), ||(or)로 연결하는 것도 가능
    
    3) 중첩해서 사용 가능
    
    ⭐️분기 : 선택적으로 코드를 실행 시키는 것⭐️
    
    접근연산자
    
    var id = “abcdef”
    
    id.isEmpty   ==  false
    
    id.dropFirst  == “bcdef”
    
3. 반복

---

### Switch문

- 표현식/변수를 (매칭시켜) 분기처리 할때 사용하는 조건문(if문보다 한정적인 상황에서 사용

내부적인 메커니즘은 비교, “==”와 만 비교

ex)

```swift
var choice: String = “가위”

switch choice{
case “가위”:
print(”가위 입니다.”)
case “바위”:
print(”바위 입니다.”)
case “보”:
print(”보 입니다.”)
default:
print(”기본 케이스의 경우”)

}
```

[스위치문의 특징]

 -   1) 스위치문에서 케이스의 ,(콤마)는 또는 의 의미로 하나의 케이스에

여러 매칭값을 넣을 수 있음

2) switch문은 (비교하고 있는)값의 가능한 모든 경우의 수를 반드시 다루어야 함(exhaustive: 하나도 빠뜨리는 것 없이 철저한)모든 사례를 다루지 않았을 때에는 디폴트 케이스가 반드시 있어야 한다.

3) 각 케이스에는 문장이 최소 하나 이상 있어야 하며 만약 없다면 컴파일 에러 발생(의도하지 않은 실수를 방지 목적) 실행하지 않으려면, break를 반드시 입력해야함 (if문에서는 실행문을 입력안해도 괜찮지만, 스위치문에서는 필요함)

fallthrough 키워드 ⇒ switch문의 비교(매칭)와 상관없이 다음 블럭을 실행

범위연산자, 패턴매칭 연산자(참과 거짓의 결과가 나옴)

0…50 = 0~50까지의 숫자

switch 변수 {

case 값1 :

 code

case 값2,값3:

 code

case 값4:

 code

default:

 break

}



switch age{

 case 1…10 :

code

 case 10…20 :

code

 case 20…30 :

code

default:

break

}

Switch문의 활용

- 스위치 문과 밸류바인딩
- 다른 변수/상수의 새로운 식별자로 할당

스위치문과 where절 (스위치 문에서 조건을 확인하는 방식)

### 튜플(Tuples)

- 2개 이상의 연관된 데이터(값)를 저장하는 Compound(복합/혼합) 타입
- 특별하게 타입이 정해져 있지 않음
- 포함될 데이터 갯수를 마음대로 정의하기 나름

멤버(데이터의 종류 및 갯수)는 튜플을 만들때 결정되므로 “추가”/”삭제” 불가

연관된 값(튜플)의 각각의 데이터의 접근

threeValues.0

threeValues.1

threeValues.2

### Named Tuple 이름이 매겨진 튜플 // 코드의 가독성이 좋아짐

튜플의 활용

- 튜플의 바인딩 패턴을 사용해 바인딩 가능

where절을 사용하여 조건확인 하여 튜플케이스를 처리 할 수 있음

---

# 삼항연산자와 범위연산자

### 삼항연산자(Ternary Conditional Operator)

- 기본 형태 / if문보다 조금은 한정적인 형태로 사용 가능

ex)  var a = 10

if/else문

if a > 0 {

print(”1”)

}else{

print(”2”)

}

삼항연산자

a > 0 ? print(”1”) : print (”2”)

삼항연산자는 조건에 따라 선택이 두가지인 경우에만 삼항연산자를 사용한다

- 사용예시
    
    var name = a > 0 ? “스티브” : “팀쿡”
   
    ⭐️단독으로 쓰이기 보다는, 결과 값을 대입하는 데 주로 사용⭐️
    

### 범위연산자

- 제한된 숫자의 범위를 표기하기 위한 연산자. 자체가 특별한 타입을 의미
    
    예시) 1 … 10
    
- 규칙 - 내림차순 형식으로 표기 불가능 (내림차순으로 변환은 가능)
    
           - 실수 형식의 범위도 가능(다만, 사용하는 경우 드뭄)
    
- 특정한 경우에 활용 - 1. switch문에서 패턴 매칭에 사용, 2. for문과 주로 함께 사용(정수인 경우), 3. 배열의 서브스크립트 문법과 함께 사용

### 패턴매칭 연산자 (~=)

- 오른쪽에 있는 표현식이 왼쪽의범위에 포함되는 지에 따라 참과 거짓을 리턴 (true, false)

**var** age = 31

**if** 20...29 ~= age {

print("20대 입니다.")

}

// 스위치문은 내부적으로 패턴매칭 연산잘로 구현이 되어있음

**switch** age {

**case** 20...29:

print("20대 입니다.")

**case** 30...39:

print("30대 입니다.")

**default** :

**break**

}

## 프로그래밍의 기본 원리

- 모든 프로그래밍은 세가지 논리로 이루어 진다.

  1) 순차 -코드작성 순서,  2)조건 -if, switch 와 같은 조건  3)반복 -for, while과 같은 반복실행

### 반복문

1) for 문

예시)

for i in 1…10{

print(i)

}

출력값 ⇒ 1,2,3,4,5,6,7,8,9,10

*와일드카드 패턴  = _[언더바]는 스위프트에서 생략의 의미

for _ in 0…10{

print(”hello”)

}

- 배열 등 컬렉션 타입에서도 사용 가능

let list = [”Swift”, “Programming”, “Language”].   <= 배열

for str in list{

print(”str”)

}

출력 ⇒ “Swift”, “Programming”, “Language”

- 문자열에서도 사용 가능

for chr in “Hello” {

print(chr)

}

H, e, l, l, o

stride(from: 1, to: 15, by: 2) // 1, 3 ,5 ,7 ,9 ,11 , 13 마지막 숫자는 포함하지 않음 (기본룰)

### ********************************************************for문 사용 시 주의점********************************************************

for문에서 선언하는 변수는 for문 내에서만 사용이 가능(Scope와 관련)

코딩에서의 대원칙 : 중괄호 내에서 밖의 변수는 접근가능, 중괄호 밖에서 중괄호 내의 변수는 접근 불가능

*중괄호의 의미 = 범위(Scope)

### While문

조건이 거짓이 될 때까지 일련의 명령문 수행(반드시 while문 내부에서 조건을 변화시키는 일이 일어나야함)

repeat-While문의 기본형태

일단 한번은 실행하고 나서, 조건을 판단해서 실행

조건(컨디션)이 마지막에 있음

루프를 통과하난 각 패스의 끝 부분에서 조건을 평가

var i = 1

repeat {

print(”\(3) * \(i) = \(3 * i)”)

i += 1

} while i <= 9

While, repeat-While문의 차이

while 참과 거짓을 판단할 수 있는 문장{

code

*조건에 변화를 주는 문장

}

repeat-While문

repeat{

code

*조건에 변화를 주는 문장

}while 참과 거짓을 판단할 수 있는 문장

while문과 동일. 다만, 조건에 관계없이 일단 문장을 실행하고 난뒤, 조건에 따라 반복적으로 실행할지 여부 확인 후 다시 실행

## 제어전송문

- 반복문에서 쓰이는 제어전송문

1) continue

for num in 1…20{

if num % 2 == 0{

continue

}

print(num)

}

⇒ 나머지가 0인 숫자를 만나면 다음 반복문으로 넘김, 결과 값: 1,3,5,7,9,11,13,15,17,19

2)break

for num in 1…20{

if num % 2 == 0{

break

}

print(num)

}

⇒나머지가 0인 숫자를 만나면 멈춤, 결과 값 : 1

*중첩 사용 시 가장 인접한 범위의 반복문에 영향을 끼침

for i in 0…3 {

print(”OUTER \(i)”)

for j in 0…3 {

if i > 1 {

print(”   j : “, j )

continue

//break

}

print(”    INNER \(j)”)

}

}

레이블이 매겨진 문장에 사용

반복문을 중첩적으로 사용할때, 각 반복문에 이름을 붙여서, 가장 인접한 범위 이외의 반복문도 제어가능

OUTER: for i in 0…3 {

print(”OUTER \(i)”)

INNER: for j in 0…3 {

if i > 1 {

print(”   j : “, j )

continue

//break

}

print(”    INNER \(j)”)

}

}

---

### 함수

함수의 기본개념

- 어떤 기능을 하는 코드 모음이며, 입력과 출력이 있을 수 있음

- 함수는 항상 2단계로 실행 됨 - (1) 정의 , (2) 호출(또는 실행)

함수의 기본형태

-정의

func doSomething() {

code

}

-실행

doSomething()

### 함수 사용의 이유

- 반복되는 동작을 단순화해서 재사용 가능
- 코드를 논리적 단위로 구분 가능
- 코드 길이가 긴 것을 단순화해서 사용 가능
- 미리 함수를 잘 만들어 놓으면, 개발자는 사용만 하면 됨(내부적 내용을 몰라도 사용 가능)

파라미터의 사용(ex. (name: String)

- 매개변수/인자 : 함수의 정의에 입력값으로 사용되는 변수(상수)

func saySomething(name: String) {

print(”안녕하세요, \(name)”)

}

saySomething(name: “스티브”)

⇒ 안녕하세요, 스티브

void 타입의 이해 (아웃풋이 없는 경우)

func sayhello() → ()  : 생략

리턴타입이 없는 함수 → 결과는 Void타입

리턴타칩이 있는 함수 → 결국 결과로 “값”이 있는 것 → (일반적으로)사용

### 함수의 파라미터, 아규먼트

1) 아규먼트 레이블

함수 내부에서는 단축어로 사용 가능, 아규먼트 값 입력 시 함수내부에서 원하는 데이터를 입력 할 수 있도록 설명이 가능하도록 기재 가능

2) 아규먼트 레이블을 생략해서 사용하는 것도 가능(와일드카드 패턴)

func addPrintFunction(_ firstNum: Int, _ secondNum: Int) {

print(firstNum + secondNum)

}

addPrintFunction(1, 2)

3) 가변파라미터 - 함수의 파라미터에 정해지지 않은, 여러개의 값을 넣는 것도 가능

1. 하나의 파라미터로 2개이상의 아규먼트를 전달할 수 있다
2. 아규먼트는 배열형태로 전달된다.
3. 가변 파라미터는 개별함수마다 하나씩만 선언할 수 있다.(선언 순서는 상관없음)
4. 가변 파라미터는 기본값을 가질 수 없다.

4) 함수의 파라미터에 기본값(디폴트) 정하는 것도 가능

### 함수 사용시 주의점⭐️

1) 함수의 파라미터에 대한 정확한 이해

func somAdd(a: Int) → Int {

//let a: Int 이라는 의미

return a

}

파라미터를 변경하면서 사용하고 싶을때

함수 내에 변수 선언이 필요함

func someAdd(a: Int) → Int {

var b = a

b += 1

return b

}

2) 함수 내의 변수의 Scope(스코프)

- 함수 내에서 선언한 변수의 Scope(범위) → 함수의 바디로 제한됨

-중괄호 내에 선언 된 변수는 중괄호 안에서만 사용 가능

3) return 키워드의 정확한 이해

*return 키워드의 역할*

*1) 리턴타입이 있는 함수의 경우(아웃풋이 있는경우):*

*리턴 키워드 다음의 표현식을 평가(계산)한 다음에 그 결과를 리턴하면서 함수를 벗어남*

*2) 리턴타입이 없는 함수의 경우(아웃풋이 없는경우):*

*함수의 실행을 중지하고 함수를 벗어남 ⭐️*

4) 리턴타입이 있는 경우, 함수의 실행문의 의미

리턴 타입이 있는 함수를 호출하는 경우, 함수를 호출하는 것은 표현식  (표현식의 결과는 함수가 리턴하는 값)

5) 함수의 중첩 사용 - 중첩된 함수 (Nested Function)

- 함수 안에 함수를 작정할 수도 있다.
- 함수 안에 있는 함수는 밖에서 사용이 불가능
- 함수를 제한적으로 사용하고 싶을 때 사용

함수 사용시 주의점(실수를 많이하게 되는 부분)



함수를 지칭하려는 경우, 함수를 어떻게 표기할까?

1) 개발자 문서를 읽을 때 필요

2) 함수를 지칭할때 필요 (함수를 변수에 담거나)

함수 타입의 표기

변수에 정수를 저장하는 경우에 타입 표기

함수 표기법(지칭)

함수의 실행문이 아닌 함수를 지칭하는것

---

## 함수의 오버로딩

- 같은 이름의 함수에 매개변수(파라미터)를 다르게 선언하여, 하나의 함수 이름에 실제 여러개의 함수를 대응 시키는 것  ⇒ 쉽게 말하면 : 함수의 이름의 재사용
- 스위프트는 오버로딩을 지원하는 언어
    
    ⇒ ⭐️함수이름, 파라미터 수/자료형, 아규먼트 레이블, 리턴형을 모두 포함해서 함수를 식별
    

### Scope(스코프)

범위에 대한 이해

중괄호의 의미(범위:Scope)

코딩에서의 대원칙 : 중괄호 내에서 밖의 변수는 접근 가능,

중괄호 밖에서 중괄호 내의 변수는 접근 불가능

- 함수, if, for문 등에 모두 해당
1. 변수는 코드에서 선언이 되어야 접근 가능(선언하기 이전에는 접근 불가함)(전역변수는 예외)
2. 상위 스코프에 선언된 변수와 상수에 접근가능하며, 하위스코프에는 접근 할 수 없다.
3. (동일한 스코프에서 이름이 중복될수 없지만, 다른 스코프에서는 이름 중복이 가능)
    
    가장 인접한 스코프에 있는 변수와 상수에 먼저 접근 한다.
    

### 제어전송문 정리

1) break

1. switch문 2. 반복문(for/while 등)에서 사용

switch문- case 에서 실행하는 문장이 없을때, 반드시 입력

반복문 - 가장 인접한 반복문을 중지

2) fallthrough

- switch문에서 사용

3) continue

- 반복문에서 사용 (for/while)

4) return

- 함수에서 사용

5) throw

- (에러가 발생할 수 있는)throwing함수에서 사용


---

## inout 파라미터

- 함수내의 파라미터는 기본적으로 값타입이고(복사되어 전달) 임시상수이기 대문에 변경 불가 원칙

함수내에서 변수를 직접 수정하도록 돕는 inout 키워드 (참조(저장된 주소)로 전달)

- inout 키워드(선언시), &사용(실행시)

func swapNumbers(a: inoput Int, b: inout Int) {

var temp = a

a = b

b = temp

}

swapNumbers(a: &num1, b: &num2)

(1)정의 파라미터 타입 앞에 inout 키워드 추가 : 파라미터의 복사본이 전달되는 것이 아니라 원본이 전달됨(내부적으로 (copy-in copy-out)매커니즘)

inout파라미터 사용시 주의점

1) 상수 (let)나, 리터럴 전달하는 것 불가능

2) 파라미터의 기본값 선언을 허용하지 않음

3) 가변파라미터(여러개의 파라미터)로 선언하는 것 불가능

### 가드문(guard)

if문과 유사하게 쓰이는 guard문 (guard: 감시하다.)

기본구조 - guard true(condition) else { return false }

guard문

1) else문을 먼저 배치 - 먼저 조건을 판별하여 조기 종료(early exit)

2) 조건을 만족하는 경우 코드가 다음 줄로 넘어가서 계속 실행

3) 가드문에서 선언된 변수를 아래문장에서 사용 가능 ( 동일한 스코프로 취급)

조건을 만족하지 않는 경우) else 이른판별 후 조거 종료가 가능해짐 (early exit)

조기종료 함수에서는 return, throw / 반복문에서는 break, continue

조건을 만족하는 경우) 코드가 다음줄로 넘어가서 계속 실행 *일반적으로 조건으로 걸러낼 때 사용


discardableResult

tuple 사용하는 이유

## 옵셔널(Optional)

옵셔널 타입

-

---

### Foundation / UIKit

왜 import Foundation 또는 import UIKit이 필요할까? (iOS Architecture / iOS SDK)

(애플 또는 누군가)미리 만들어 놓은 함수, 기능들을 사용하기 위해 import를 해야 함

import 를 하지 않으면 기본적인  Swift언어만 사용 가용

(타입, 조건/반복문, 컬렉션, 이외에 기타 Swift문법적인 기능 등..)

[Data/ Date 타입도 있으 Foundation이 없으면 사용 못함,Foundation에 있는 NSData/ NSDate를 감싸는 형태의 타입]

Foundation Framework (추가 기능)

앱을 만들때 반드시 필요한 기능들

NSData / NSDate 타입, 데이터와 날짜

런루프 RunLoop

Selector

Timer / 알림 등

멀티쓰래드 - GCD / NSThread / Thread 등

네트워크 - URL

JSON

앱 지역화 관련

UIKit > Foundation

Cocoa Touch Framework 앱 개발 기초 / 필수적인 기능 등

Media Framework 다양한 미디어 기능 구현 필요 기능 등

Core Services Framework 시스템 서비스 제공 데이터 접근 등

Core OS Framework 보안 / 하드웨어 연동 등

# 클래스(Class)와 구조체(Struct)



- 클래스와 구조체 둘다, 메모리에 찍어낸 것을 인스턴스(instance)라고 함
- 인스턴스는 실제로 메모리에 할당되어 구체적 실체를 갖춘 것이라는 의미
- 스위프트에서는 클래스의 instance를 특별히 객채(object)라고 부름
- 클래스의 인스턴스(객채)
- 구조체의 인스턴스
- 열거형의 인스턴스



### 가장 큰 차이는 메모리 저장 방식의 차이

1) 구조체(Struct)

 - 값 형식 (Value Type)

 - 인스턴스 데이터를 모두 스택에 저장

 - (복사시) 값을 전달할때마다 복사본을 생성 (다른 메모리 공간 생성)

 - 스택의 공간에 저장, 스택 프레임 종료시, 메모리에서 자동 제거

2) 클래스(Class)

 - 참조형식(Reference Type)

 - 인스턴스 데이터는 힙에 저장, 해당 힙을 가르키는 변수는 스택에 저장하고

 - 메모리 주소값이 힙을 가르킴

 - (복사시) 값을 전달하는 것이 아니고, 저장된 주소를 전달

 - 힙의 공간에 저장, ARC시스템을 통해 메모리 관리(주의해야함)

- 클래스의 경우 주소를 저장하는 방식이므로 복사된 변수 주소의 ‘값’이 공유 됨(메모리 주소 공유)
- 구조체의 경우 주소가 아닌 값을 복사하는 방식으로 데이터영역에서 복사된 기본값을 저장(데이터 값을 복사)


  p = Class (힙 영역 주소 복사/변경된 값 복사), a = Struct(스택 내 선언)

클래스에서 선언된 let은 주소의 선언이므로 값 변경 가능(여기서 선언된 let은 주소를 변경할수 없다는 뜻)

구조체에서 선언된 let은 값의 선언이므로 속성그대로 값 변경 불가능(여기서 선언된 let은 값)

접문법 (.) / 명시적 멤버 표현식(Explicit Member Experssion)의 정확한 의미

*관습적인 부분

- 일반적으로 클래스, 구조체 선언할때 모두 (속성 → 메서드) 순서대로 작성

⭐️주의 클래스,구조체 안(정의)에는 실행문이 올 수 없다⭐️

### init(생성자): initializer  - 초기화(파라미터)

사용법

- 변수에 타입만 선언

      var name: String

      var weight: Double

- init(n: String, W: Double) {
    
         [self.name](http://self.name) = n
    
         self.weight = w
    
    }
    

inti 메서드 이용시 인스턴스와 파라미터의 구분을 위해 self를 붙여주어야 한다

[self.name](http://self.name) (self. 의 의미 : 인스턴스를 지칭)

인스턴스내에서 동일한 변수명, 상수명을 사용할때  가르키는 것을 명확하게 하기 위해 self키워드를 사용

self키워드는 클래스/구조체 내에서 해당 인스턴스(자기자신)를 가르킴

- 초기화 메서드/이니셜라이저
- nit(파라미터)
- 모든 저장 속성(변수)을 초기화 해야함  (구조체, 클래스 동일)
- 생성자 실행 종료시점에는 모든 속성의 초기값이 저장되어 있어야 함(초기화가 완료되지 않으면 컴파일 에러)

 - 클래스 , 구조체, (열거형)은 모두 설계도 일뿐이고,

 - 실제 데이터(속성), 동작(메서드)을 사용하기 위해서는 ===> 초기화 과정이 반드시 필요함

인스턴스 초기화 완료 → 메모리에 정상적으로 인스턴스가 생성

**‘초기화’** 메모리에 인스턴스를 생성하기 위한 필수 과정

옵셔널 타입으로 선언시 자동으로 nil(값이 없음 표기) 로 초기화를 하기 때문에 앱 에러가 나지 않음

파라미터 선언 없이 선언을 할 경우엔 기본값으로 제시

식별연산자(Identity Operator)

두개의 참조가 같은 인스턴스를 가르키고 있는지를 비교하는 방법

===, !==

print(dog1 === dog2)

print(dog1 !== dog2)

객체지향 프로그래밍의 필요이유 = 의미있는 데이터를 묶음으로 만드려는 것

클래스와 구조체를 사용하는 이유! 사용하려는 모델의 설계 = ( DTO - Data Tranfer Object )관련 데이터를 한곳에 담는 역할



- 연관된 데이터들을 단순히 캡슐화 하는것이 목적일때 구조체 사용
- 캡슐화한 데이터를 참조하는 것보다 복사해서 사용하는 것이 효율적일때 구조체 사용
- 구조체에서 저장된 저장 속성들이 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때 구조체 사용

- 데이터에서 상송의 구조가 필요하면 클래스 사용
- 해당모델을 serialize 해서 전송하거나 파일로 저장할 경우가 발생하면 클래스 사용

## 객체지향

OOP의 4대 특징

1) 추상화 - 관찰자가 관심있는 부분만 가지고 재조합 하는 것(ex. 도서관리 프로그래밍 만들 때, 모두 필요한 것이 아니라 책 제목, 가격, 출판사, 저자 정도만 필요할 경우 필요한 부분만 재조합 하여 하나의 분류로 만드는 것)

2)캡슐화 - 연관이 있는 속성과 메서드를 하나의 클래스로 묶어서 활용한다는 개념 ↔ 은닉화(접근 통제)

3)상속성 - 부모클래스의 속성과 메서드를 자식클레스에서 그대로 물려받는 개념

4)다형성 - 여러가지타입의 형태로 저장될 수 있고, 다양한 방식으로 동작 가능(동적 바인딩)

캡상추다



### 저장속성(Stored Properties)

⇒ 구조체, 클래스 동일

 - let 또는 var 로 선언 가능

 - 저장 속성은 각 속성자체가 고유의 메모리 공간을 가짐

 - 초기화 이전에 값을 가지고 있거나, 생성자 메서드를 통해 값을 반드시 초기화 해야만 함(옵셔널의 경우 nil로 초기화 되어있음)

 

### 지연저장속성(Lazy Stored Properties)

 ⇒ lazy var 변수이름

인스턴스가 초기화되는 시점에 해당 속성이 값을 갖고 초기화 되는 것이 아니라(메모리 공간과 값을 가지는 것이 아니라, 해당 속성(변수)에 접근하는 순간에 (해당 저장 속성만)개별적으로 초기화 됨

let(상수)사용 불가 var 만 선언 가능

⭐️선언시점에 초기화 기본값을 제공해야함, 생성자(init)에 선언 불가능(메모리가 할당되어있지 않기 때문)

지연저장속성 사용하는 2가지 이유

1) 메모리 낭비를 막기 위해

2) 지연 저장 속성으로 선언되는 속성이 다른 저장 속성을 이용해야 할 때

(var a 에 선언된 속성을 이용해 var b 를 실행 해야 하나 동시에 메모리가 생성 되기 때문에 a 이용이 불가하므로  var a  우선 생성 후 lazy var b 를 통해 a의 속성을 사용)

### 계산속성(Computed Properties)

get 읽기 계산속성 ( 읽기만 가능한 계산속성 (read-only)은 get블록 생략 가능

set 쓰기 계산속성

### 정의

- 실제로, 계산 속성은 겉모습은 속성(변수)형태를 가진 메서드(함수)임 ⭐️
- 계산 속성은 실제 메모리 공간을 가지지 않고, 해당 속성에 접근했을때 다른 속성에 접근해서 계산한후,
그 계산 결과를 리턴하거나 세팅하는 메서드 이다.
- 두가지 관련 함수를 한번에 구현 가능
- 외부에서 보기에 속성이름으로 설정 가능하므로 보다 명확해 보임
- 계산속성은 실제 메모리 공간을 가지지 **않고**, 해당 속성에 접근 했을때 다른 속성에 접근해서 계산한 후, 그 계산 결과를 리턴하거나 세팅하는 메서드 이다.

### 주의점

구조체, 클래스, 열거형 동일

1) 항상 변하는 값이므로 var(변수) 선언 해야함 (let 선언 불가)

2) 자료형 선언을 해야함(타입/추론 안됨) 메서드이기 때문에 파라미터, 리턴형이 필요함

3) get은 반드시 선언 해야함(값을 얻는 것은 필수, 값을 설정하는 것은 선택)

get{

let bmi = weight / (height * height) * 10000

return bmi

}

set(bmi) {

weight = bmi * height * height / 10000

}

set 블럭에서 파라미터 미 입력 시 newValue로 지정

### 타입속성 (Type Properties)

static(고정적인) 키워드를 추가한 저장 속성

static var species: String = “Dog”

타입 속성의 메모리 구조의 이해

- 저장 타입 속성
- 일반 저장속성은 인스턴스를 생성할때, 생성자에서 모든 속성을 초기화, 해당 저장 속성은 각 인스턴스가 가진 고유한 값임
- 저장 타입 속성은 **생성자가 따로 없기때문에**, 타입 자체에 속한 속성이기 때문에 항상 기본값이 필요
- 지연 속성의 성격을 가짐

### 주의점

- 구조체, 클래스, 열거형 사용 가능
- let, var 둘다 선언 가능
- 타입 속성은 인스턴스에 속한 속성이 아니기 때문에 인스턴스 이름으로는 접근 불가

### 속성 감시자(Property Observer) //저장 속성 감시자

willSet / didSet

                                   적용 시점

willSet —————————값 변경 ————————— didSet

속성 감시자를 추가 가능한 경우

1) 저장 속성 (원래, 상속한 경우 둘다 가능)

2) 계산속성 (상속해서 재정의 하는 경우에만 가능) - 자주 만나지는 않음

let(상수)속성에는 당연히 추가 안됨 (값이 당연히 변하지 않으므로) v

알고리즘의 복잡도

빅 오(Big-O)표기법 - 최악의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지 표시 : O(N)

## 매서드

### 인스턴스 메서드

### 타입 메서드

### 서브스크립트

### 접근제어

private 선언된 속성/메서드는 접근 불가하므로 코드 내부의 세부 구현내용을 숨기는 것이 가능(은닉화)

[접근제어가 필요한 이유]

- 애플이 자신들이 원하는 코드를 감출 수 있음
- 코드의 영역을 분리시켜서, 효율적 관리 가능
- 컴파일 시간이 줄어듬(컴파일러가, 해당 변수가 어느범위에서만 쓰이는지를 인지 가능

### 싱글톤 패턴

메모리상에 유일하게 1개만 존재하는 객체 설계

static let shared = 객체생성() [class 객체생성 명]

…

private init() {}

## 클래스의 상속과 초기화

### 상속은 쉽게 말해, 본직적으로 성격이 비슷한 타입을 새로 만들어, 데이터(저장속성)을 추가하거나,메서드(기능)을 변형시켜 사용하려는 것

기본(Base)클래스 다른 어떤 클래스도 상속하지 않은 클래스(아무것도 상속하지 않은 1번(날것)의 개념)

(상대적인 기준)부모클래스/슈퍼클래스/상위클래스

(상대적인 기준)자식클래스/서브클래스/하위클래스

상속 = Subclassing

## 클래스의 상속과 재정의

저장속성은 재정의가 불가능 하다

오버로딩(overloading) - (과적) 함수에서 함수의 하나의 이름에 여러 함수를 대읗시켜서 사용

오버라이딩(overriduing) - (재정의) 클래스의 상속에서 상위클래스의 속성/메서드를 재정의(기능을 약간 변형하여 사용) 하는 것

재정의 - 서브클래스에서 슈퍼클래스의 동일한 멤버를 변형하여 구현

재정의 가능한 대상(멤버)

1) 속성 / 하지만, 저장 속성에 대한 재정의는 어떠한 경우에도 불가능

2) 메서드 / 메서드, 서브스크립트, 생성자

super.doSometing() 으로 상위메서드 호출 가능

속성과 메서드는 재정의 방식이 다름

⭐️저장속성의 재정의는 원칙적 불가 (데이터구조의 변형은 불가)

 

⭐️클래스 상속과 재정의 규칙의 중요도⭐️


(1) 저장 속성의 재정의

원칙적으로 불가능 (고유의 메모리 공간은 유지 해야함)

—>저장 속성은 고유의 메모리 공간이 있으므로 하위클래스에서 고유의 메모리 공간을 바꾸는 방식으로의 재정의는 불가능

(메서드 형태로 추가하는 방식의 재정의는 가능)

—>읽기/쓰기 가능한 계산속성으로 재정의 가능(메서드) (읽기만 가능한 계산 속성으로 정의 불가능 - 기능 축소는 불가능  get/set 필수)

—> 속성 감시자를 추가는 가능(메서드) (실질적 단순 메서드를 추가해서 저장 속성이 변하는 시점을 관찰할 뿐)

(2) 계산 속성(메서드)의 재정의

(실질적인 메서드이기 떄문에 메서드 형태로의 재정의만 가능. 기능의 범위를 축소하는 형태로의 재정의는 불가능)

(상위)읽기전용 계산 속성을 —> (하위) 읽기/쓰기가 가능한 속성으로 재정의 가능(확장 O)

                                          —> 속성 감시자를 추가하는 재정의는 불가능 (읽기 전용 속성을 관찰 할 수 없음 - 논리에 안 맞음)

(상위)읽기/쓰기 계산 속성을 —> (하위)읽기만 가능한 속성으로만 재정의 불가능(기능제한 X)

                                           —> 속성 감시자를 추가하는 재정의 가능 (관찰은 가능)

-읽기 메서드 —> 읽기메서드

-쓰기 메서드 —>         X     (불가능)

-읽기 메서드 —> 읽기메서드

-        X        —> 쓰기메서드 (가능) // 확장은 가능

인스턴스 속성의 대원칙

1) 저장 속성 재정의는 원칙적으로 불가능 (하위 속성에서 상위 속성의 고유의 메모리 공간을 변형 불가)

    메서드 방식(계산 속성으로의 재정의 가능)으로 추가는 가능

2) 계산 속성의 유지/확장은 가능, 축소는 불가능

3) 속성 감시자(메서드)를 추가하는 재정의는 언제나 가능(실질적 단순 메서드 추가)

    (다만, 읽기전용 계산 속성을 관찰하는 것은 의미 없으므로 불가능)

-(실질적으로 드뭄)

-타입 속성의 재정의 원칙

1) 타입 저장 속성은 재정의 불가 - static키워드 (계산속성으로 재정의하거나, 속성 감시자를 추가하는 것도 불가능)

2) 타입 계산 속성 - class 키워드인 경우 계산 속성 재정의 (확장방식) 가능

3) 재정의한 타입 저장/계산 속성에는 감시자 추가 원칙적으로 불가

속성에 비해, 메서드의 재정의는 자유로운 편(다만, 생서자의 재정의는 메모리 생성 규칙이 존재)

초기화의 방법(저장속성이 초기값 가져야 함)

1) 저장 속성의  선언과 동시에 값을 저장

2) 저장 속성을 옵셔널로 선언(초기값이 없어도 nil로 초기화 됨 *var 변수 선언만 가능)

3) 생성자에서 값을 초기화

-반드시 생성자를 정의해야만 하는 것은 아님

컴파일러는 기본 생성자를 자동으로 생성함 ⇒ init()

이니셜라이저를 구현하면 기본생성자를 생성하지 않음

- 멤버와이즈 이니셜라이저 - 구조체의 특별한 생성자
- 구조체(struct)에서는 이니셜라이저를 구현하지 않아도 자동으로 생성해줌

Memberwise  = 멤버에 관하여 (~wise : ~에 관하여)

모든 멤버에 관련된 생성자라는 뜻, 구조체에서만 제공

구조체 에서는 기본생성자 포함하여 추가적으로 멤버와이즈 생성자도 제공함

 이니셜라이저를 따로 구현하면 멤버와이즈 이니셜라이저가 자동으로 제공되지 않음⭐️

 

구조체는 다른 생성자를 호출하는 방식도 가능

init() {

self.init(red: 0.0, green: 0.0, blue: 0.0)

}

---

## 지정생성자, 편의생성자

class에서 이니셜라이저를 호출하려면 convenience를 입력해 주어야 한다

원래 생성자의 이름을 지정생성자 라고 함 기본생성자 init()

*편의생성자는 편리하게 생성하기 위한 서브생성자라고 보면 됨

메인/지정 생성자에 의존하는 방식(지정 생성자 호출)

지정 생성자는 모든 속성을 초기화 해야함(기본 생성자)

편의 생성자는 모든 속성을 초기화 할 필요가 없음

클래스는 상속을 지원하므로, 변수가 여러개 이고, 여러 지정 생성자를 지원했을때 상속 관계에서 개발자가 실수 할 수 있는 여러가지 가능성을 배재하기 위한 생성자임, 초기화 과정을 간편하게 하기 위함도 있음,

반대로, 모든 속성을 초기화하지 않는다면 편의생성자로 만드는 것이 복잡도나 실수를 죽일 수 있음, 가능한 중복을 없애고 다른 지정생성자를 호출하는 패턴으로 구현해야 함

그래야 나중에 수정시 개발자의 실수를 줄일 수 있음

이미 모든 속성을 초기화하는 지정생성자가 있다면, 모든 속성을 초기화 하지 않는 경우 편의생성자로 구현을 권장

클래스에서 상속이 일어나면

1) 새로 만들어진 저장속성값을 세팅 해야함

self.z = z

2) 상위의 지정생성자를 호출해야 함

super.init(x: x, y: y)

생성자 위임 규칙(Initializer Delegation)

- (1) 델리게이트 업(Delegate up)

-     서브클래스의 지정생성자는 수퍼 클래스의 지정생성자를 반드시 호출해야함

- (2) 델리게이트 어크로스(Delegate across)

-     편의생성자는 동일한 클래스에서 다른 이니셜 라이저를 호출해야하고, 궁극적으로 지정생성자를 호출해야함


## 생성자의 상속/재정의

지정생성자 / 편의생성자 상속과 재정의 규칙

생성자

- 생성자는 기본적으로 상속되지 않고 재정의 원칙
- 원칙 : 1) 상위 지정생성자와 2) 현재 단계의 저장 속성을 고려해서 구현

1단계 : 상위지정생성자 : 재정의 필수 고려

      편의 생성자 : 재정의 불가

## 실패가능 생성자

initializer 뒤에 ? 를 붙여 nil값을 출력할 수 있도록 정의

생성자에 ?를 붙여서 init?(파라미터) 라고 정의하면 실패가능 생성자로 정의되는 것임

(다만, 동일한 파라미터를 가진 생성자는 유일해야함. 오버로딩으로 실패가능/불가능을 구분 짓지 못함)

struct Animal {

let sepcies: String

init?(species: String) {

if sepecies.isEmpty {                                .isEmpty←→=== “” (빈문자열) → Bool 값 출력

return nul

}

self.sepecies = species

엄밀히 말하면 생성자는 값을 반환하지 않고, 초기화가 끝날 때까지 모든 저장 속성이 값을 가져 올바르게 초기화 되도록 하는 것임

초기화 성공을 나타내기 위해 return키워드를 사용하지 않음

동일단계 - 델리게이트 어크로스

- 실패가능 == > 실패 불가능 (호출/위임) OK
- 실패불가능 == > 실패 가능 (호출/위임)   X

상속관계 - 델리게이트 업

- (상위)실패가능 < == (하위)실패불가능 (호출/위임)  X
- (하위)실패불가능 < == (하위)실패가능 (호출/위임) OK

![그림 확인 하여 가능/불가능 여부 쉽게 확인 가능(실패가능 의 경우 nil을 포함하기 때문)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e414ae1b-4c3c-4f89-bd56-5777a90b2a2d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.27.15.png)

그림 확인 하여 가능/불가능 여부 쉽게 확인 가능(실패가능 의 경우 nil을 포함하기 때문)

상속관계에서 재정의하기

(상위)실패가능 == > (하위)실패불가능 재정의 (OK) (강제 언래핑 활용 가능)

(상위)실패불가능 == > (하위)실패가능 재정의 (X)

init? == > init!    위임가능

init! == > init?

init? == > init! 로 재정의 가능

init! == > init?

init == > init! 위임가능 ⇒ 실패 할 수도 있어짐

클래스 정의 시 클래스에는 최대 1개의 소멸자를 정의 가능


---

PROTOCOL

*협약/규약, 자격증 같은 존재.

- 상속의 단점을 보완(단일상속 및 필요없는 기능 상속)을 위해 도입
- 별도의 기능으로 존재
- 구조체 및 개별 클래스에 채택/사용 가능
- 다중채택도 가능함

프로토콜의 문법

1) 정의

2) 채택

3) (속성/메서드) 구체적인 구현

속성의 요구사항 정의

protocol 에서는 let을 선언할 수 없음 var만 선언 가능 (최소한의 요구사항)

protocol RemoteMouse {

var id: String { get }    //채택으로 구현 let 저장속성 / var  저장속성 / 읽기계산속성 / 읽기,쓰기 계산속성

var name:String { get set }      // 저장속성 / 읽기, 쓰기 계산속성

static var type: String { get set }       // 타입 저장속성(static)

                                                                    //타입 계산속성(class)

}

프로토콜은 프로토콜간에 상속이 가능하고 다중 상속이 가능

포로토콜도 상속이 가능 / 다중 상속이 가능

protocol Remote {

func turnOn()

func turnOff()

}

protocol AirConRemote {

func Up()

func Down()

}

protocol superRemoteProtocol: Remote, AirConRemote {        //프로토콜끼리, 상속 구조를 만드는 것이 가능

func turnOn()

func turnOff()

func Up()

func Down()

func doSomething()

}

프로토콜을 합성하여 임시타입으로 활용 가능

ptorocol Named {

var name: String { get }

}

protocol Aged {

var age: Int { get }

}

하나의 타입에서 여러개의 프로토콜을 채택하는 것 당연히 가능(다중 상속과 비슷한 역할)

struct Person: Named, Aged {

var name: String

var age: Int

}

프로토콜을 두개를 병합해서 사용하는 문법(&로 연결)

func widhHappyBirthday(to celebrator: Named  & Aged) {

print(”생일축하해, \(celebrator.name), 넌 이제 \(celebrator.age)살이 되었구나!”)

}

let birthdayPerson = Person(name: “홍길동”, age: 20)

wishHappyBirthday(to: birthdayPerson)

let whoIsThis: Named & Aged = birthdayPerson    //일시적인 타입으로 저장 (두개의 프로토콜을 모두 채택한 타입만 저장 가능)

어트리뷰트 ⇒ 컴파일러에게 알려주는 특별한 신호이자, 추가적인 정보를 제공 (2가지 종류가 있음)

1) 선언에 대한 추가정보 제공

2) 타입에 대한 추가정보 제공

-사용 방법

-@어트리뷰트이름  ⇒ @available

-@어트리뷰트이름(아규먼트)   ⇒@available(iOS 10.0)

@objc는 스위프트로 작성한 코드를 오브젝티브C 코드에서도 사용할 수 있게 해주는 어트리뷰트

-프로토콜에서 요구사항 구현시, 반드시 강제하는 멤버가 아니라 선택적인 요구사항으로 구현할때 사용

-프로토콜 앞에는 @objc 추가

멤버 앞에는 @objc optional 을 모두 추가

오브젝티브-C에 해당하는 클래스 전용 프로토콜임 (구조체, 열거형 채용불가)

(오브젝티브C는 구조체와 열거형에서 프로토콜 채택을 지원하지 않음)

## 프로토콜의 확장 → 기본(디폴트) 구현 제공

프로토콜을 채택한 모든 타입에서, 실제 구현을 계속적으로 반복해야하는 불편함을 덜기 위해 프로토콜 확장을 제공해서 메서드의 디폴트 구현을 제공함 (코드의 중복을 피할 수 있음)

프로토콜 확장 시 기본값 외 실제 적용한 프로토콜을 채택한 구현시 작성한 메서드가 먼저 적용됨

1. (채택)구현시 해당 메서드, 2.기본(값) 메서드 로 적용

Virtual Table 클래스의 메서드 테이블

Witness Table 목격자 테이블 - 프로토콜에서 필수 구현 메서드 테이블

Direct Dispatch 직접 메서드 주소 삽입

## 프로토콜지향 프로그래밍의 구조적   차이



프로토콜 확장에서 where절을 통해, 프로토콜의 확장의 적용을 제한 가능

특정 프로토콜을 채택한 타입에만 프로토콜 확장이 적용되도록 제한

where Self : 특정 프로토콜

프로토콜의 확장 중 where절을 통해 특정 프로토콜을 정의 한 뒤, 채택하지 않으면 프로토콜의 확장이 적용되지 않기 때문에 확장이 없는 것과 동일하게, 메서드를 직접구현 해야한다

//특정 프로토콜을 채택한 타입에만 프로토콜 확장이 적용되도록 제한

중첩타입의 목적

 

1) 중첩타입으로 선언된 API들을 볼줄 알아야함

    DataFormnatter.Style.full

    (중간 타입에 대문자가 나오면, 중첩타입임을 인지)

2) 실제 앱을 만들때 중첩 선언을 잘 활용해야 함(타입 간의 관계 명확성)

3) 하나의 타입의 내부 구조(계층 관계 등)를 디테일하게 설계 가능


let formatter = DataFormatter()

formatter.dataStyle = DataFormatter.Style.long *중첩 타입으로 설계 됨을 인지하고, 사용할 필요(DataFormatter와만 관계있는 타입)

사용시에는

1) 중첩타입 전체를 쓰거나

DataFormatter.Style.long

2) 타입추론이 가능하므로 줄여서 사용 가능

.long

mutating ⇒ 구조체, 열거형에서 변경 불가능한 변수를 변경할 수 있도록 허용 하는 키워드

함수를 실행할때 파라미터로 전달하는 함수를 callback함수 라고 부름

클로저 = 이름이 없는 함수(*더 정확하게는 힙에 올라가는 함수)

클로저는 메모리 주소를 갖고 있음

함수(클로저)를 힙 영역에 저장하는 이유 : 함수를 변수에 저장 하여 사용(오래사용하기 위함), 변수를 통해 함수접근 가능

외부에 저장된 변수를 사용 함과 동시에 저장된 함수가 외부 변수에 누적 됨 // 함수는 외부 변수를 캡처한다 (지속적으로 사용하기 위해) === > 캡처 현상

함수를 변수에 저장하는 경우 / 함수를 더 오랫동안 사용하겠다는 것

함수의 주소를 힙의 영역에 저장 (참조 타입)

함수의 주소를 저장할 뿐만 아니라, 함수 외부에 위치하여 계속 사용하는 변수도 캡처

---

## 클로저의 문법 최적화

1) 문맥상에서 파라미터와 리턴밸류 타입 추론(Type Inference)

2) 싱글 익스프레션인 경우(한줄), 리턴을 안 적어도 됨(Implicit Return)

3) 아규먼트 이름을 축약(Shorthand Arguments) === > $0, $1

4) 트레일링 클로저 문법  : 함수의 마지막 전달 인자(아규먼트)로 클로저 전달되는 경우, 소괄호를 생략 가능

1. 트레일링(Trailing) 클로저 - 후행 클로저 문법

func closureParamFunction(closure: () → void) {

print(”프린트 시작”)

closure()

}

closureParamFunction(closure: () → void) ← 인풋(함수)

                👇🏻       (후행 클로저인 경우 아래와 같이 인풋 함수 생략 가능)

closu   reParamFunction {

code

}

1. 후행 클로저 문법

func closureCaseFunction(a: Int, b: int, closure : (Int) → void) {

let c = a + b

closure(c)

}

closureCaseFunction(a: int, b: Int) { num in

print(”출력 \(num)”)

}

1. 파라미터 및 생략 등의 간소화

//함수의 정의

func performClosure(param: (String) → Int) {

param(”Swift”)

}

1) 타입 추론(Type Inference)

performClosure(param: { (str: String) → Int in

return str.count

})

performClosure(param: { str in

return str.count

})

2) 한줄인 경우, 리턴을 안 적어도 됨(Implicit Return)

performClosure(param: { str in

str.count

})

3) 아규먼트 이름을 축약(Shorthand Argements)

performClosure(param: {

$0.count

})

4) 트레일링 클로저

performClosure(param: {

$0.count

})

performClosure() {

$0.count

})

performClosure { $0.count }

performClosure { str in

return str.count

})


클로저의 @escaping 키워드 - 내부 함수(클로저)를 외부로 탈출 시켜 사용할 수 있도록 하는 키워드

non-escaping : 함수내부에서, 단순하게 실행하고 종료할때(클로저를 힙에 저장할 필요 없음)

@escaping : 함수의 실행을 벗어나서도 실행되도록 하는 키워드, 내부 클로저를 외부**’변수’**에 저장/GCD(비동기코드 사용)

@autoclosure키워드

자동으로 클로저를 만들어 준다// 클로저 앞에 @autoclosure 키워드 사용(파라미터가 없는 경우(void)에)

일반적으로 클로저 형태로 써도 되지만, 너무 번거로울때 사용

번거로움을 해결해 주지만, 실제 코드가 명확해 보이지 않을 수 있으므로 사용 지양(애플 공식 문서)

잘 사용하지 않음, 읽기위한 문법

autoclosure는 기본적으로 non-escaping 특성을 가지고 있음

### 실제 프로젝트 클로저 사용 예시
 

---

### *고차함수란?

“함수”를 파라미터로 사용하거나, 함수실행의 결과를 “함수”로 리턴하는 함수

인풋 또는 아웃풋, 인풋 아웃풋 모두 함수를 사용 하는 함수를 고차함수라 함

1) map 함수

2) filter 함수

3) reduce 함수

4) forEach 함수

5) compactMap 함수

6) flatMap 함수

- Collection(배열, 딕셔너리, 세트 등)에 기본적으로 구현되어 있는 함수

---

1 - map 함수

- 기존 배열 등의 각 아이템을 새롭게 매핑해서(매핑방식은 클로저가 제공) 새로운 배열을 리턴하는 함수
- (각 아이템을 매핑해서, 변형해서 새로운 배열을 만들때 사용)

let numbers = [1, 2, 3, 4, 5]

numbers.map(closure) { num in

code

}

[배열.map](http://배열.map) { 클로저 }

기존의 배열의 각 아이템을 새롭게 매핑해서(매핑방식은 클로저가 제공) 새로운 배열을 리턴

매핑 = 구역을 나누어 특정 값을 할당한다

어떤 형태의 타입으로도 이용 가능

2 - filter  함수

- 기존 배열 등의 각 아이템을 조건(조건은 클로저가 제공)을 확인 후, 참(true)을 만족하는 아이템을 걸러내서 새로운 배열을 리턴
- (각 아이템을 필터링해서, 걸러내서 새로운 배열을 만들때 사용)

3 - reduce 함수

- 기존 배열 등의 각 아이템을 클로저가 제공하는 방식으로 결합해서 마지막 결과값을 리턴(초기값 제공 필요)
- (각 아이템을 결합해서 단 하나의 값으로 리턴)

배열.reduce()

map / filter / reduce 의 활용⭐️

각 기본 고차함수(map, filter, reduce)의 의미를 정확하게 파악한 후 여러가지를 조합해서 다양하게 활용 가능(실제, 앱을 만들때 데이터를 다루기 위해서 많이 활용)

1. forEach 함수
- 기존 배열 등의 각 아이템을 활용해서  각 아이템별로 특정 작업(작업 방식은 클로저가 제공)
- (각 아이템을 활용해서 각각 특정 작업을 실행할때 사용)
- 배열 내 각각의 요소들을 활용하여 각개 작업

1. compactMap 함수
- 기존 배열 등의 각 아이템을 새롭게 매핑해서(매핑방식은 클로저가 제공)변형 하되, 옵셔널 요소는 제거하고, 새로운 배열을 리턴
- (map + 옵셔널제거)
- 옵셔널은 빼고, 컴팩트(compact)하게
- (옵셔널 바인딩의 기능까지 내장)
- 옵셔널 값(nil)을 제외 하고 배열 매핑 출력

1. flatMap 함수
- 중첩된 배열의 각 배열을 새롭게 매핑해서(매핑방식은 클로저가 제공)
- 내부 중첩된 배열을 제거하고 리턴
- (중첩배열을 flat하게 매핑)
- 중첩 배열의 탈출

스위프트의 프로그래밍 패러다임

- 객체지향 프로그래밍(Object-Oriented Programming) - 클래스의 상속을 활용한 프로그래밍, 상속의 단점이 존재
- 프로토콜 지향 프로그래밍(Protocol-Oriented Programming) - 객체지향 프로그래밍의 단점을 보완하고자 프로토콜을 사용해 활용성 높은 프로그래밍을 지원 하도록 개발된 프로그래밍 방법
- 함수형 프로그래밍(Functional Programming)

## 함수형 프로그래밍이란

### FP(Functional Programming)이란?

명령형 프로그래밍(imperitive)

변수 지정 / for문 → 부작용(side-effect)

How - 어떻게 구현해낼까? / 설계

ex)

var sum = 0

for num in 배열 {

sum += num

}

함수형 프로그래밍 / 선언형(FP)

가져다 붙이기만 하면 됨(함수의 조합) / 선언적

WHAT - (어떤 것을) 가져다 붙이면 결과가 나올까

함수를 이용해서(사이드이펙트가 없도록) 선언형으로 프로그래밍 하는 것

ex)

[배열.map](http://배열.map) { 클로저 }

.filter { 클로저 }

.reduce(0) { 클로저 }

함수를 이용해서 선언형으로 프로그램이 하는 것

[함수형 프로그래밍]

- 함수를 이용해서, "사이드 이펙트가 없도록" 선언형으로 프로그래밍 하는 것

(함수형 프로그래밍은 결과를 도출하기 위해 "함수"를 사용하는 것에 지나지 않음)

- 산에 올라가는 방법은

1)"산을 걸어서 올라가는 방법"(명령형)  vs  2) "헬리곱터에서 정상에서 내리는 방법"(함수형)

[함수형/선언형]

- 개발자는 중간과정을 신경쓰지 않고,

- 이미 정의된 함수를 가지고 "어떻게 조합해서 결과를 만들어 낼까"만 신경쓰면 됨

- ==> 모두가 map/filter/reduce의 쓰는 방법을 알고 있기 때문

- 간결한 코드 작성이 가능해짐 ⭐️

- SwiftUI에서 사용하는 방식

- 클로저를 자유자제로 사용!

## 옵셔널 체이닝(Optional Chaining)

### 규칙

-옵셔널 타입으로 선언된 값에 접근해서, 속성, 메서드를 사용할때 접근연산자(.)앞에 ?(물음표)를 붙여야 함

(앞의 값이 옵셔널의 가능성을 내포한다는 의미)

1) 결과는 항상 옵셔널타입으로 리턴

2) 옵셔널 체이닝 과정에서 그 값 중 하나라도 nil을 리턴한다면, 이어지는  표현식을 평가하지 않고 nil 리턴

1) 함수 관련 표기법

choco?.sit?()?.name  - sit? ← 함수가 없을 수 있다 / sit?()? ← 함수의 결과값이 없을 수 있다.

2) 딕셔너리 관련 표기법

books?[”Apple”]?.name - books? ← 딕셔너리가 없을 수(nil)있다 / [”Apple”]? ← 딕셔너리의 결과값이 없을 수 있다.

3) 함수의 실행은?

bori?.sit()

1 - 리턴형이 없는 함수의 경우 nil아니면 → 함수실행 / nil이면 → nil반환

2 - 리턴형이 있는 함수의 경우 nil아니면 → 옵셔널 타입으로 변환 / nil 이면 → nil반환

# 메모리 관리 모델


## ARC(Autumatic Reference Counting)

### **강한 참조 사이클(Strong Reference Cycle) = 메모리 누수 원인**

객체가 서로를 참조하는 강한 참조 사이클로 인해, 변수의 참조에 nil을 할당해도 메모리 해제가 되지 않는 메모리누수의 상황이 발생

bori?.owener = gildong

gildong?pet = bori

강한 참조 사이클로 인한 메모리 누수 해결 방안

Weak Reference(약한 참조), Unowned Reference(비소유 참조)

Strong Reference Cycle 사용시 주의점

클래스의 인스턴스에서는 메모리 누수를 막기 위해 RC의 기능이 있어, 컴파일러가 자동으로 코드를 심어준다,

그러나 서로를 가르키는 경우 강한 참조가 일어나 ARC로도 해결이 안될 수도 있기 때문에 Weak/Unowned 키워드를 이용 해 약한 참조 사이클로 만들어 메모리 누수를 막는다.

### 클로저/ 클로저의 값타입 캡처

값타입의 갭처현상 / 값타입 캡처리스트

let valueCaptureClosure = {

print(”밸류값 출력(캡처): \(num)”)

}

let valueCaptureListClosure = { [num] in

print(”밸류값 출력(캡처리스트): \(num)”)

}

- 캡처현상: 클로저는 (클로저의 주기동안 사용이 필요 없어질떄까지) 힙(Heap)의 영역에 존재해야하고, (클로저)내부에서 외부에 존재하는 변수를 계속 사용해야 하기때문에 캡처 현상이 발생

[캡처리스트를 사용하는 이유]

1) 값 타입은 값을 복사/캡처 (외부적인 요인에 의한 값 변경 방지)

2) 참조타입은 캡처리스트내에서 (메모리 주소를 캡처) weak(약한)/unowned(비소유) 참조 선인이 가능 (강한 참조 해결 가능)

밸류타입의 캡처는 당연하게 클로저 외부에 존재하는 밸류 타입의 참조(변수 주소)를 캡처함

클로저 외부에 존재하는 값을 복사해서 사용함

참조타입의 캡처

클로저 외부에 존재하는 참조타입의 참조(변수 주소)를 캡처함(외부 요인에 의해 해당 값이 변했을때도 계속 참조)

클로저 외부에 존재하는 참조타입의 주소값을 복사해서 사용

(외부요인에 의해 해당 인스턴스의 해제를 방지할때 사용 → 즉, 가르키는 인스턴스의 RC를 올라가게 함으로써, 메모리에서 해제될 가능성을 방지)


## DispatchQueue관련 코드

코드 , 데이터 , 힙 영역의 메모리는 공유, 각 각의 스택은 공유하지 않음

DispatchQueue.global().async = 2번째 쓰래드에서 실행 코드

## 에러 처리(Error Handling)

(에러를 던질 수 있는)함수와 처리

func checking(a: Int) throws → Bool {} 함수 정의 : “에러를 던질 수 있는 함수이다.”라는 키워드 필요

do / catch 문을 사용 하여 에러 처리가 가능한 함수 사용

do : 정상적인 처리

catch : 에러가 발생했을 경우의 처리


에러 처리의 3단계

1) 에러 타입의 정의 (enum: 열거형 으로 case 나열 후 Error 프로토콜 채택 필수)

2) 함수 정의 (throws 키워드 사용 & 에러가 발생 가능한 상황에 throw 키워드)

3) 에러 처리 (정상적인 처리 방법 : do-catch 블럭에서 처리)

### 에러처리 방법 try / try?(Optional try) / try! (Forced try)

(1) try

do {

let data = try parsing()

} catch {

}

- 모든 에러발생의 예외적인 경우를 디테일하게 처리 가능

(2) try?

let data = try?parsing()

- 결국 옵셔널 타입으로 리턴하기 때문에 벗겨서unwrapping) 사용해야 함(nil, optional 값 출력)

(3) try!

let dat = try!parsing()

- 에러가 발생할 가능성이 없는 경우에 제한적으로 사용(런타임 오류 발생)

### catch블럭의 처리 방법

1) 패턴을 모두 정의 (경우를 모두 따로 처리)

각 catch블럭에서 모든 경우를 정의 하거나, 구체적인 경우를 먼저 정의하고, 마지막엔 catch키워드만 있어도 됨 , 를 통하여 여러개 나열 가능

2) 패턴없이 에러를 받아서 처리

catch블럭 내에서 error 상수 제공

error상수(에러 프로토콜 타입)를 구체적으로 정의한 타입으로 캐스팅해서 스위치문 등으로 다시 처리

**do {**

**let _ = try parsing()**

**print(”놀이기구 타는 것 가능”)**

**} catch {**

**if let error = error as? SomeError {**

**switch error {**

**//처리**

**}**

**}**

**}**

### 에러를 던지는 throws키워드를 사용한 콜백 함수를 파라미터로 사용할 경우 rethrows키워드를 사용 해야 한다.

Defer문 : 연기 시키다 (할일을 미루는 defer문에 대한 이해)

디퍼문이 호출 되어야  해당 디퍼문의 실행이 예약되는 개념

디퍼문은 등록한 역순으로 실행 == > 일반적으로 하나의 디퍼문만 사용하는 것이 좋음

func deferStatement() {

defer {

print(1)

}

defer {

print(2)

}

defer {

print(3)

}

deferStatement() = >  실행 시 3, 2, 1 순으로 출력

HTTP 규약

4 계층

APP(편지지) →  애플리케이션: HTTP  / 리퀘스트 - 요청 = 데이터를 어떻게 주고 받을지에 대한 약속(요청/응답)

OS(편지봉투) → 트랜스포트: TCP / 조각,PORT붙임 (연결/순서/검증) = 주고 받을 상태 확인 및 검증/PORT (어떤 앱과 통신하는지)

      → 인터넷: IP = 주고 받는 주소(경로)

LAN(상자) → 링크: 네트워크 / MAC주소 추가

시작라인 / 헤더필드(header field) / 공백라인 / 메세지 본문 (message body)

메소드 + 요청대상(경로) + HTTP버전

모든 부가 정보 (HTTP 전송에 필요한 메타데이터 )

실제 전송할 데이터 (JSON / HTML 문서 / 이미지 / 영상 등)

## **네트워킹**

### HTTP 프로토콜 / 요청 메소드의 종류


*PATCH - > 좋아요/즐겨찾기 등의 기능

### CRUD

C - CREAT = POST

R - READ = GET

U - UPDATE = PUT

D - DELETE = DELETE

## 네트워킹

### HTTP 프로토콜 / 응답 상태 코드


200번대 정상 처리 / 성공

400번대 에러는 클라이언트 에러

500번대 에러는 서버 에러 (서버다운 / 정기점검)

GET 메서드 사용 시 ?q=swift&hl=ko

- key=value의 형태 - q=swift
- ?로 시작, &로 추가 가능


**Response(응답) 데이터의 형태 / 앱에서 처리하는 데이터의 형태(JSON)**


API =  요청방식에 대한 약속

REST한 형식의 API (예전엔 SOAP)

REST한 형식 = 명사형으로 작성을 하자

https://(사이트 주소)/movielists

https://(사이트 주소)/movielists?open=tomorrow

https://(사이트 주소)/movie-reservation

1. URL
2. URLSession
3. dataTask
4. 시작(resume)
    

    dataTask 가 HTTP 요청 메세지를 변환하여 서버에 전달 → 서버에서 응답 메세지를 전달(클로저 형태)
    
    동기 / 비동기 처리의 개념
 
    
    **비동기(Async)** - 작업을 다른 쓰레드에서 하도록 시킨 후, 그 작업이 끝나길 “안 기다리고” 다음일을 진행한다.(안 기다려도 다음 작업을 생성할 수 있다.)
    
    **동기(Sync)** - 작업을 쓰레드에서 하도록 시킨 후 , 그작업이 끝나길 “기다렸다가” 다음일을 진행한다.(기다렸다가 다음 작업을 생성할 수 있다.)
    
    비동기라는 개념이 일반적으로 필요한 이유는? 대부분은 서버와의 통신(네트워크 작업) 때문
    
    Serial(직렬) vs Concurrent(동시)
    
      ㅇㄹ
    
    **직렬(Serial) 처리** - (보통 메인에서) 분산처리 시킨 작업을 “다른 한개의 쓰레드에서” 처리
    
    **동시(Concurrect) 처리** - (보통 메인에서) 분산처리 시킨 작업을 “다른 여러개의 쓰레드에서” 처리
    
    ### **비동기 ≠ 동시**
    
    다른 쓰레드에 task 실행 / 여러개의 쓰레드에서 처리
    
    기다리지 않고 기존 쓰레드 작업 실행 할 수 있도록 분산 처리
    
    GCD / Operation
    

    Queue = 대기열
    
    task = 작업
    
    클로저는 작업을 하나로 묶음
    
    global() - 일반적인
    

GCD. Queue의 종류

디스패치큐(GCD)에 대해서

1. DispatchQueue(GCD)
2. OperationQueue

Thread 1 = 메인쓰래드 = 메인 큐

큐의 서비스 품질의 개념

iOS가 알아서 우선적으로 중요한 일임을 인지하고 쓰레드에 우선순위를 매겨 더 많은 쓰레드를 배치하고 CPU의 배터리를 더 집중해서 사용하도록 해서 일을 빨리 끝내도록 하는 개념

 - 절대적인 개념은 아님 -

GCD 사용 시 주의사항

1) 반드시 메인큐에서 처리해야하는 작업

메인 Thread = 화면을 그려주는 작업을 하는 쓰레드이므로 UI관련 업데이트는 메인쓰레드에서만 진행해야 함

**DispatchQueue.global().async {**

**// 비동기적인 작업들 ===> 네트워크 통신 (데이터 다운로드)**

**DispatchQueue.main.async {**

**// UI와 관련된 작업은**

**}**

**}**

2) 컴플리션핸들러의 존재이유 - 올바른 콜백함수의 사용

⇒ 결국 비동기작업이 명확하게 끝나는 시점을 알고, 어떤 작업을 할 필요

3) weak, strong 캡처의 주의 - 객체 내에서 비동기코드 사용 시

대부분의 경우, 캡처리스트안에서 seakj self로 선언하는 것을 권장

4) 동기함수를 비동기적으로 동작하는 함수로 변형하는 방법

오래걸리는 일반적인 함수를 내부에 비동기적 처리를 하면 비동기로 동작하는 함수로 변형 가능

 

Thread-safe 하지 않음

멀티 쓰레드의 환경에서, 같은 시점에 여러개의 쓰레드에서 하나의 메모리에 동시접근 하는 문제

경쟁상황 or 경쟁조건 이라고도 표현

DeadLock의 개념

멀티 쓰레드의 환경에서, 베타적인 메모리사용으로 일이 진행이 안되는 문제

교착상황

2개이상의 쓰레드가 서로 배타적인 메모리의 사용으로 인해(서로 잠그고 점유하려고 하면서)메서드의 작업이 종료도 못하고 일의진행이 멈춰버리는 상태

Thread-safe하지 않을때, 처리하는 방법 ⇒ 동시큐에서 직렬큐로 보내기

한번에 여러개의 쓰레드가 접근할때 경쟁상황으로 인한 누락이 있을 수 있으므로, 직렬큐로 보내 누락없이 Thread-safe하도록 만든다

## 제네릭(Generics)

제네릭 문법은 타입별로 따로 구현할 필요 없이, 제네릭문법을 통해 함수를 정의하면 어떤 타입을 이용하든 제네릭문법을 적용한 함수를 이용할 수 있다

*형식에 관계없이, 한번의 구현으로 모든 타입을 처리하여 타입에 유연한 함수 작성가능 (유지보수/재사용성 증가)

제네릭 함수를 정의하는 방법

func printArray**<T>**(array: **[T]**){

for number in array {

print(number)

}

}

타입 파라미터<T>는 함수 내부에서 파라미터의 타입이나 리턴형으로 사용됨(함수 바디에서 사용하는 것도 가능)

(1) 관습적으로 Type(타입)의 의미인 대문자 T를 사용하지만, 다른 문자를 사용해도 됨 <U> <A> <B> <Anything> (Upper camel case 사용해야 합)

(2) <T, U> <A, B> 이렇게 타입 파라미터를 2개이상도 선언 가능

(1) 타입 파라미터의 지정

- 함수의 이름 마지막에 <>를 쓰고, 안에 타입 파라미터 작성 / 실제 타입 대신에 사용하는 ‘플레이스 홀더’ 역할 (어떤 타입이 입력되어야 한다는 것을 제시)

(2) 타입 파라미터의 사용

- 본래 타입의 사용하는 위치(파라미터, 바디, 리턴형)에서 타입이 필요한 곳에 타입 파라미터 사용

⇒ 실제 함수 호출시에 실제 타입으로 치환

(3) 제네릭 타입 확장시

- 타입 파라미터 명시없이 확장 (확장 옆에는 플레이스 홀더 작성 불가), 본 체의 제네릭에서 정의한 타입 파라미터 사용 가능

### 제네릭에서 사용하는 타입에 대한 제약을 줄 수 있는 2가지 방법

(1) 프로토콜 제약 <T:  Equatable>

 - 특정 프로토콜을 따르는 타입만 가능하도록 제약

(2) 클래스 타입 제약 <T: SomeClass>

 - 특정 클래스와 상속관계 내에 속하는 클래스 타입만 가능하도록 제약

클래스, 구조체, 열거형의 타입이름 뒤에 타입 파라미터<T>를 추가하면, 제네릭 타입으로 선언됨

속성의 자료형, 메서드의 파라미터형식, 리턴형을 타입 파라미터로 대체 가능

특정 클래스와 상속관계 내에 있는 클래스만 타입으로 사용할 수 있다는 제약 ( 구조체, 열거형은 사용 못함 )

항상 제네릭을 적용시킨 함수를 실행하게만 하면, 또다른 불편함이 생기지 않을까?

- 제네릭 함수가 존재하더라도 동일한 함수이름에 구체적인 타입을 명시하면, 해당 구체적인 타입의 함수가 실행됨

### 프로토콜에서 제네릭의 사용 - Associated Types(연관 타입)

protocol RemoteControl {

associatedtype T

func changeChannel(to: T)

func alert() → T?

}

- 연관형식이 선언된 프로토콜을 채용한 타입은, typealias로 실제 형식을 표시해야함

프로토콜은 타입들이 채택할 수 있는 한차원 높은 단계에서 요구사항만을 선언(자격증)하는 개념이기 때문에 제네릭 타입과 조금 다른 개념(연관타입)을 추가적으로 도입한 것 뿐

연관형식에 제약 추가 가능

(1) 연관 타입의 지정 프로토콜에서는 연관타입(형식)으로 선언해야함

*associatedtype(연관타입)이라는 키워드를 쓰고, 옆에 타입 파라미터로 사용할 문자 작성

타입 파라미터는 대문자로 시작하면 상관없음 (예) A, U, Element

프로토콜을 채택하는 타입 내부에서 실제 타입으로 사용됨

프로토콜에서 ‘플레이스 홀더’ 역할 (어떤 타입이 입력되어야 한다는 것을 제시)

타입을 제약하는경우 예시)

associatedtype T: Equatable

(2) 프로토콜의 채택 및 연관 타입의 사용

- 타입앨리어스를 사용해서 명시적으로 타입 표시(치환)(생략가능)
- 생략가능하기 때문에, 실제 타입을 구현한 함수 등에서 단순히 실제 타입을 사용하면 됨

## Result Type : Result

- 성공/실패 의 경우를 깔끔하게 처리가 가능한 타입
- 기존의 에러처리 패턴을 완전히 대체하려는 목적이 아니라, 개발자에게 에러 처리에 대한 다양한 처리 방법에 대한 옵션을 제공

Result Type의 내부 구현

enum Result

case .success    ← 성공타입

case .failure    ← SomeError


기존 에러처리 3단계

(1) 에러타입 정의

(2) 함수 정의

(3) 에러 처리  → 결과처리 (Result Type 처리의 경우, switch 문을 통해 결과처리만 하면 됨, 명시적)

func resultTypeCheckingHeight(height: Int) → Result<Bool,HeightError> {

if height > 190 {

return Result.failure(HeightError.maxHeight)

} else if height < 130 {

return Result.failure(HeightError.minHeight)

} else {

if height >= 160 {

return Result.success(true)

} else {

return Result.success(false)

}

}

}

### 날짜와 시간 다루기

Date / Calendar / DateFormatter

Calendar

(1) Date의 요소(년/월/일/시/분/초 등)로 분리가능하도록 만드는 구조체

.component 요소를 출력 하는 속성

var age: Int {

get {

let year = Calendar.current.component(.year, from: Date())

return year = yearOfBirth

}

class 에서는 private 개념의 경우 중괄호 내에서만 사용 가능하다라는 선언이기때문에 애초에 성립이 되지 않으므로, class 의 private는 fileprivate와 같다

내부 멤버를 명시하지 않으면 internal로 유지

## 상속과 확장의 접근제어

- **1)타입 관련: 상속해서 만든 서브클래스는 상위클래스보다 더 높은 접근 수준을 가질 수는 없음**
- **2)멤버 관련: 동일 모듈에서 정의한 클래스의 상위 멤버에 접근가능하면, (접근 수준 올려서) 재정의(override)도 가능**

상속 관계 주의점 - (1) 상속에서 만든 하위 클래스는 상위클래스 보다 더 높은 접근 수준 설정이 안됨

                       (2) 동일 모듈에서 정의한 클래스의 상위 멤버에 접근 가능하면, (접근 수준 올려) 재정의 가능

### private(set)

저장, 계산속성의 읽기와 쓰기의 접근제어 수준을 구분해서 구현가능

-변수 및 속성, 서브스크립트에 쓰기(setter)수준을 읽기(getter)수준 보다 낮은 접근 수준으로 설정 가능

### 스위프트의 문자열에서는 배열같은 단순 인덱스(index)접근이 불가능

       String      ——————>      NSString

스위프트 문자열                    Objective-C 문자열

-구조체                                 -클래스

-문자열.count                      -문자열.length

NSAttrubutedString 타입

(가끔 앱에서 반드시 필요한 경우가 있음)

스위프트 문자열에서 온전히 구현할 수 없는 기능이 있음

예시) 약관 확인 또는 계정 정보 (클릭 가능한 문자열)

## 스트링 인터폴레이션 (String Interpolation)  : \(  ) [ file. 24 - 3 ]


출력 형식 지정자  (참고) [file. 24 - 4]

**https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html#//apple_ref/doc/uid/TP40004265-SW1**

“%.d” = 정수

“%.f”  = 소수

형식 지정자 (문자열 경우)

var firstName = “Gildong”

var lastname = “Hong”

var korean = “사용자의 이름은 %2$@ %1$@ 입니다.”

var english = “The username is %1$@ %2$@”

1$ 첫번째 파라미터, 2$ 두번째 파라미터 …

- **"숫자" <====> "문자" 변환을 다루는 클래스**

**- NumberFormatter()**

**[설정 가능 속성]**

**.roundingMode              반올림모드**

**.maximumSignificantDigits  최대자릿수**

**.minimumSignificantDigits  최소자릿수**

**.numberStyle               숫자스타일**

세자리수마다 콤마 넣기

numberFormatter.numberStyle = .decimal

let price = 10000000

let result = numberFormatter.string(for: price)

print(result) // 10,000,000


**서브 스트링**

저장속성 내의 문자열을 사용할때, 새로운 메모리를 생성하지 않고 기존의 메모리 공간을 공유하는 것

var greeting = “Hello world!”

let index: String.Index = greeting.firstIndex(of: ”,”) ?? greeting.endIndex // 닐 코얼레싱

let beginning: String.SubSequence = greeting[..<index] 처음부터 인덱스까지

- prefix(…)메서드 등의 사용 시
- “Hello”란 beginning문자열은 greeting문자열의 메모리 공간을 공유
- 스위프트 내부적으로 최적화되어 있음
- 수정 등이 일어나기 전까지 메모리 공유
- 오랜기간 저장하기 위해서는, 새롭게 문자열로 저장 필요

*prefix = 접두어

# 문자열 다루기

### 문자열을 배열로 변환

문자열(데이터바구니) ←→ 배열 (쉽게 변형가능)

var someString = “Swift”

문자열을 문자열 배열화 하기

var array: [String] = [someString.map](http://someString.map) { String($0) }

문자열배열을 문자열로 변경

var newString = array.joined()       //Character 배열은 joined 메서드가 존재하지 않음

map 고차함수, joined() 활용 기억 하기

// map고차함수를 사용해서 변환

**newString3 = someString .map { String($0) }.shuffled().joined()**

**print(newString3)**


### 문자열 다루기

- 문자열의 대소문자 변형 (스위프트는 대문자와 소문자를 다른 문자로 인식(유니코드 다름))

var string = “swift”

string.lowercased() //전체 소문자

string.uppercased() //전체 대문자

string.capitalized //대문자로 시작하는 굴자로 리턴

- 빈 문자열과 공백 문자열은 다름

var emptyString = “ “   //[공백]이 포함된 문자열

emptyString.count    //1

emptyString.isEmpty     //false

emptyString = “”  //[빈] 문자열 (nil이 절대 아님)

emptyString.count    //0

emptyString.isEmpty    //true

### 문자열에선 정수형의 인덱스를 사용하지 못한다

- **문자열의 인덱스는 정수가 아님 ⭐️**

**- (스위프트는 문자열을 글자의 의미단위로 사용하기 때문에, 정수 인덱스 사용 불가)**

**[String.Index 타입]**

**- 문자열.startIndex**

**- 문자열.endIndex**

**- 문자열.index(<#T##i: String.Index##String.Index#>, offsetBy:**       //가장 많이 쓰임 **<#T##String.IndexDistance#>)**

**- 문자열.index(after: <#T##String.Index#>)**

**- 문자열.index(before: <#T##String.Index#>)**

**- (다만, 인덱스의 크기 비교는 당연히 가능)**

**- 문자열.indices     (인덱스의 모음)**

**- (인덱스를 벗어나는 것에 주의)**

**- 문자열.firstIndex(of: <#T##Character#>)**

**- 문자열.lastIndex(of: <#T##Character#>)**

**[String.Index 범위]**

**- 문자열.range(of: <#T##StringProtocol#>)**

**- 문자열.range(of: <#T##StringProtocol#>, options: <#T##String.CompareOptions#>, range: <#T##Range<String.Index>?#>, locale: <#T##Locale?#>)**

**- String.Index를 이용, 서브스크립트 활용가능 ⭐️**

**[String.Index의 정수형태로 거리는 측정 가능]**

**- 문자열.distance(from: <#T##String.Index#>, to: <#T##String.Index#>)**



삽입(insert) / 교체(replace) / 추가(append) / 삭제(remove)

대소문자 무시하고 비교하는 메서드 존재 → caseInsensitiveCopare(문자열)

→ 단순 같은지 틀린지 뿐만아니라, 결과가 오름차순/내림차순인지 알수 있어서 결과값이 활용성이 높고 보다 구체적인 정보 제공가능(다만, 처음 사용하는 입장에서 헷갈릴 수 있으므로 잘 알고 사용해야하는 불편함이 있을수 있음)

### **String.CompareOptions (비교 옵션)**

**==========================================**

**[String.CompareOptions 구조체]와 내부의 타입 속성들**

**- .caseInsensitive       // 대소문자 무시하고 ⭐️**

**- .diacriticInsensitive  // 발음구별기호 무시하고**

**- .widthInsensitive      // 글자 넓이 무시하고**

**- .forcedOrdering        // 강제적 오름차순/내림차순 정렬순 (대소문자 무조건 구별 의미)**

**- .literal               // (유니코드 자체로) 글자그대로**

**- .numeric               // 숫자 전체를 인식해서 비교**

**- .anchored              // (앞부분부터) 고정시키고 (접두어)**

**- .backwards             // 문자 뒷자리부터**

**- .regularExpression     // 정규식 검증 ⭐️**

**=============================================**

옵션 입력 부분

OptionSet 프로토콜 채택 시, 여러개의 옵션을 배열 방식으로 전달 가능

NsString.ComnpareOptions

### **정규식에 대한 내용을 찾으려면, 구글 및 유튜브 검색 및 활용**

**/**=========================================================**/**

**#"[0-9]{3}[- .]?[0-9]{4}[- .]?[0-9]{4}"#   // 전화번호 러프하게**

**#".*@.*\..*"#                              // 이메일 러프하게**

**#"[0-9]{3}\-[0-9]{3}"#                     // 우편번호 러프하게**

**#”[0-9]{5}”#**

**/**=========================================================**/**

**var telephoneNumRegex = #"[0-9]{3}\-[0-9]{4}\-[0-9]{4}"#**

**if let _ = number.range(of: telephoneNumRegex, options: [.regularExpression]) {**

**print("유효한 전화번호로 판단")**

**}**

[특정 문자들을 제거할때 사용하기 위한 메서드]

1) 간단하게 앞뒤의 특정 문자를 제거하는 메서드

- 문자열.trimmingCharacters(in: <#T##CharacterSet#>)

2) 문자열의 중간에 특정 문자를 제거하는 방법 ⭐️

"해당 특정 문자"를 기준으로 (잘라서) 문자열을 배열로 ===> (다시 배열을) 문자열로

- 문자열.components(separatedBy: <#T##CharacterSet#>).joined()

⭐️**(중간에 포함된)공백문자의 제거 - 자주사용**

**var name = " S t e v e "**

**var removedName = name.components(separatedBy: " ").joined()    //["", "S", "t", "e", "v", "e", ""]**

**print(removedName)**

중간에 포함된 문자 제거

1) componenets(separatedBy: “”).joined()

2) split(separator: “ “) = 클로저를 파라미터로 받을수 있음(다방면으로 구현 가능)

 **구조체로 구현되어 있는**

 **문자집합 (문자열 검색, 잘못된 문자 삭제 등에 주로 활용) (기본적인 Set성격)**

**/**=========================================**

**[CharacterSet] 유니코드 기준**

**- .symbols                // 기호**

**- .alphanumerics          // 문자 + 숫자**

**- .decimalDigits          // 10진법 숫자**

**- .letters                // 문자 (유니코드상 Letter, Mark 카테고리 해당 문자)**

**- .lowercaseLetters       // 소문자**

**- .uppercaseLetters       // 대문자  ["A", "B", "C", "D", "E" ...]**

**- .whitespaces            // 공백문자 [" "]**

**- ....등등**

**참고: https://developer.apple.com/documentation/foundation/characterset**

**============================================**/**


### 오버플로우 연산자

스위프트의 3가지 오버플로우 연산자

**[오버플로우 연산자]**

**- &+ : 오버플로우 더하기 연산자**

**- &- : 오버플로우 빼기 연산자**

**- &* *: 오버플로우 곱하기 연산자***

**- 앰퍼샌드(&)기호가 붙어있음**

스위프트에서는 오버플로우 연산자가 따로 존재

**- 스위프트의 논리 평가식은 "단락 평가" 방식을 사용**

**- 단락평가: 논리 평가식에서 결과도출에 필요한 최소한의 논리식만 평가**

**(예: 참을 찾을때 까지만 실행하고, 참을 찾으면 나머지 표현식은 평가하지 않음)**

**(최소한의 코드만 실행 - Short-circuit evaluation)**

**- 참고: 논리연산자 우선순위 1) && 2) ||**

- **단락 평가로 인한 주의 ⭐️**

**- 사이드 이팩트 발생시는 반드시 주의**

**일부 변수가 표현식의 평가 결과로 값이 변경되는 것 (여기서는 doorCheck += 1)**

**논리평가식에서 사이드 이펙트가 발생하는 경우, 단락평가로 인해 함수 등의**

**실행횟수의 차이로 인해 의도치 않은 결과가 도출될 수 있음**

**===> 논리적인 오류가 없도록 표현식을 미리 실행하도록 코드 수정**

[비트 연산]

- 메모리 비트 단위로 직접적인 논리연산을 하거나, 비트 단위 이동시에 사용하는 연산

- 주로, 어떤 하드웨어적인 처리(예, 장치 드라이버 생성)나 그래픽 프로그래밍과

임베디드 프로그래밍, 암호화처리, 게임 등 아주 한정적으로 쓰이는 이론적인 내용

(프로그래밍을 배우고 있다는 목적아래, 이론적으로 듣고 지나치면 됨)

- 장점: 1) 연산속도가 빠름 - 직접적으로 메모리의 실제 비트를 컨트롤

2) 짧은 코드로 복잡한 로직을 구현 가능한 경우가 있음

[스위프트 비트연산자 종류 6가지]

(비트 논리 연산자)

1)  ~  : Bitwise NOT Operator(비트와이즈 낫 연산자) 0/1 반전

2)  &  : Bitwise AND Operator(비트와이즈 앤드 연산자) true && true  = 1

3)  |  : Bitwise OR Operator(비트와이즈 오어 연산자) true || true = 1

4)  ^  : Bitwise XOR Operator(비트와이즈 엑스오어 연산자) // 서로 달라야 1

(비트 이동 연산자)

5)  << : Bitwise Left Shift Operator(비트와이즈 레프트 시프트 연산자)

6)  >> : Bitwise Right Shift Operator(비트와이즈 라이트 시프트 연산자)

boolean 형태로 연산 적용

 

### 비교연산자 - 연산자 메서드의 직접적인 구현

**- Equatable 프로토콜을 채택하기만 하면**

**(이 경우) 컴파일러가 연산자 메서드 구현 내용 자동 추가해줌**

**1) 열거형 - 연관값이 있으면서, 모든 연관값이 Equatable 프로토콜을 준수하는 경우**

**2) 구조체 - '저장속성'만 가지며, 저장속성의 타입이 Equatable 프로토콜을 준수하는 경우**

**- == (Equal to operator)를 구현하면 != (Not equal to operator) 자동구현**

**(두 연산자를 모두 구현할 필요 없음)**

 **연산자 메서드를 구현하면 비교가 가능해짐**

### **Equatable 프로토콜을 채택 후, 구현**

**extension Vector2D: Equatable {**

---

static func ==(lhs: Vector2D, rhs: Vector2D) -> Bool {

return (lhs.x == rhs.x) && (lhs.y == rhs.y)

}

 static func !=(lhs: Vector2D, rhs: Vector2D) -> Bool {

 return (lhs.x != rhs.x) || (lhs.y != rhs.y)

    }

---

**}**

**컴파일러가 자동으로 구현 해주므로 프로토콜만 채택해도 사용 가능**

(참고) 열거형의 경우, 연관값이 없다면 원칙적으로 동일성 비교 가능

(연관값이 전혀 없는) 열거형의 경우 굳이 Equatable프로토콜을 채택하지 않아도, 연산자(==) 메서드 자동 채택/구현

1) 주요 프로토콜 - Equatable / Comparable / Hashable

## Equatable

- static func == (lhs: Self, rhs: Self) → Bool 메서드의 구현
1. 열거형의 경우 : Equatable 프로토콜 채택시 모든 저장속성(열거형은 모든 연관값)이 Equatable프로토콜을 채택한 타입이라면 비교연산자 메서드 자동구현
2. 구조체의 경우 : Equatable 프로토콜 채택시 모든 저장속성(열거형은 모든 연관값)이 Equatable프로토콜을 채택한 타입이라면 비교연산자 메서드 자동구현
3. 클래스의 경우 : 클래스는 인스턴스 비교를 하는 항등연산자(===)가 존재하기 때문에 비교연산자(==) 구현방식에 대해 개발자에게 위임 (클래스는 원칙적으로 동일성(==) 비교 불가) / 타입메서드 직접 구현 필요

## Comparable

- static func < (lhs: Self, rhs: Self) → Bool 메서드의 구현

일반적으로 < 만 구현하면, > , <=, >= 연산자도 자동 구현

원칙) 구조체, 클래스의 모든 저장 속성(열거형은 원시값이 있는 경우)이 Comparable 을 채택한 경우라도 <(less than) 연산자 직접 구현해야 함

예외) 열거형의 경우, 원시값이 없다면(연관값이 있더라도) Comparable을 채택만 하면 <(less than)연산자는 자동 제공

클래스의 경우) Comparable프로토콜을 채택한다면 Equatable프로토콜을 상속 하므로, Comparable 타입 메서드 외 Equtable 타입 메서드 또한 구현해야 한다

## Hashable

func hash(into hasher: inout Hasher) 메서드의 구현

### 열거형의 경우

원칙) 구조체, 열거형의 경우 Hashable 프로토콜 채택시 모든 저장 속성(열거형은 모든 연관값)이

Hashable 프로토콜을 채택한 타입이라면, hash(into:)메서드 자동구현

예외)

1) 클래스는 인스턴스의 유일성 갖게 하기위해서는 hash(into:)메서드 직접 구현해야함

(클래스는 원칙적으로 Hashable 지원 불가)

2) 열거형의 경우 연관값이 없다면 기본적으로 Equatable/Hashable하기 때문에

Hashable 프로토콜을 채택하지 않아도 됨

### 구조체의 경우

원칙) 구조체, 열거형의 경우 Hashable 프로토콜 채택시 모든 저장 속성(열거형은 모든 연관값)이

Hashable 프로토콜을 채택한 타입이라면, hash(into:)메서드 자동구현

(저장속성이 Int, Double 등 이미 Hashable프로토콜을 채택해서, 유일성 판별이 가능하기 때문)

## CaseIterable ⇒ 반복 가능한

열거형에서 CaseIterable 프로토콜을 채택하면 타입 계산 속성이 자동으로 구현 됨

- static var allCases: Self.AllCases { get }
- 이 “타입 계산속성”을 컴파일러가 자동으로 구현 제공 ⇒ 모든 케이스를 (정의한 순서대로) 포함한 배열을 리턴
- 연관값이 없는 경우에만 채택 가능(원시값은 상관없음)

디버그 모드 → 앱 출시 전 에러 혹은 버그를 찾는 작업

### 디버깅 함수

디버깅(테스트/검증)을 위해 일부러 앱을 중지 시키는 함수

앱 출시전 assert() 함수를 통해 검증 진행 / 에러 확인, 잘못된 값 입력 시 에러 발생 시키도록 검증하는 함수

assert() - assertionFailure() 의 차이 / assertionFailure() 는 거짓인 경우에만 사용, assert()는 참/거짓을 구분하고 싶을때 사용

assert(), assertionFailure() ⇒ 앱 출시 전 검증 함수

precondition(), preconditionFailure() ⇒ 앱 출시 후 검증 함수

## # Keypath는 속성에 접근하기 위한 기술이다 - Objc 에서 사용하던 문법

인스턴스 → \Person.name → 특정타입.속성

                  [keyPath:경로]

## #selector - 메서드 주소를 통해 메서드를 가리키기 위한 기술

클래스, Objective-C 프로토콜에 포함된 멤버에만 적용가능(구조체 적용 불가)
 내부적으로 Objective-C 프레임워크를 사용하고 있기 때문에
 @objc 특성을 추가해야지만 사용가능

문법적인 약속

(계산)속성을 가르킬때

**let** eyesSelector = **#selector**(getter: Dog.doubleNum)    // 계산(읽기) 속성

**let** nameSelector = **#selector**(setter: Dog.doubleNum)    // 계산(쓰기) 속성

메서드를 가르킬때

**let** runSelector = **#selector**(Dog.run)

addTarge ⇒ 어떤 인스턴스의 메서드를 실행할것인지 지정

## @,#Available

(1)

**@available 키워드** 타입, 속성,메서드 앞에

@available(iOS 10.0,*)

class MyClass{…}

컴파일러가 API의 사용가능성을 결정

(2)

**#available 키워드** 조건문(if/guard/while)문에서

if #available(iOS 11.0,*) {

…

} else {

…

}

런타임에 API의 사용가능성을 결정, 조건문에 사용

/**==============================

(참고) iOS 등버전, Swift버전에 따라

- iOS

- iOSApplicationExtension

- macOS

- macOSApplicationExtension

- watchOS

- watchOSApplicationExtension

- tvOS

- tvOSApplicationExtension

- swift

================================****/**

// 참고: https://nshipster.com/available/

protocol / 고차함수 / 클로저 / 연산자 / inout 타입 / 타입캐스팅 / 생성자 / 제네릭

테이블뷰의 기본형태 - 세로로 스크롤이 가능한 뷰

- 테이블 뷰? 세로로만 스크롤 할 수 있는 형태의 뷰(내부에 셀이라는 것이 존재)
- 델리게이트 패턴을 사용(2가지 방식을 구분해서)

dataSource

delegate

(테이블뷰 ↔ 뷰컨트롤러간의 의사소통)

테이블 뷰를 사용하려면 UITAbleViewDataSource 프로토콜을 반드시 채용해야 하며, 채택에 대한 대리자로 tableVIew.dataSource = self 기재 필요

## 유저 인터페이스(즉, 화면)는 메인쓰레드에서 진행해야 함

```swift
// URL세션은 내부적으로 비동기로 처리된 함수임.
URLSession.shared.dataTask(with: url) { (data, response, error) in
    
    if error != nil{
        print("에러있음")
    }
    
    guard let imageData = data else { return }
    
    // 즉, 데이터를 가지고 이미지로 변형하는 코드
    let photoImage = UIImage(data: imageData)
    
    // 🎾 이미지 표시는 DispatchQueue.main에서 🎾
    DispatchQueue.main.async {
        imageView?.image = photoImage
    }
    
    
}.resume()
```

DispatchQueue.global().async {

비동기적인 작업들 ===> 네트워크 통신 (데이터 다운로드)

DispatchQueue.main.async {
    UI와 관련된 작업은
}

}

### GCD사용시 주의사항

컴플리션핸들러의 존재이유 - 올바른 콜백함수의 사용

데이터를 처리하는 작업(URLSession은 비동기 적인 작업)

### 잘못된 함수설계 - 비동기적인 작업을 해야하는 함수를 설계할떄 return을 통해서 데이터를 전달하려면 항상 nil이 반환

```swift
//제대로 되지 않은 설계

func getImages(with urlString: String) -> UIInage? {
    let url = URL(string: urlString)!

    var photoImage: UIImage? = nul
    
    URLSession.shared.dataTask(with: url) { (data, response, error) in
        if error != nil {
            print("에러있음: \(error!)")
        }

        guard let imageData = data else { return }
    
        photoImage = UIImage(data: imageData)
    }.resume()

return photoImage //항상 nil이 나옴

}

```

### 제대로된 함수설계 - 비동기적인 작업을 해야하는 함수는 항상 클로저를 호출할 수 있도록 함수를 설계해야함

```swift
//제대로 된 설계

func ProPerlyGetImages(with urlString: String, completionhandler: @escaping (UIImage?) -> Void) {
    let url = URL(string: urlString)!

    var photoImage: UIImage? = nil
    
    URLSession.shared.dataTask(with: url) { (data, response, error) in
        if error != nil {
            print("에러있음: \(error!)")
        }

        guard let imageData = data else { return }
    
        photoImage = UIImage(data: imageData)
    }.resume()
}
```

### 코어데이터
    
    
앱의 생명주기(Life Cycle)

1) 뷰컨트롤러의 생명주기

- **뷰 컨트롤러의 생명 주기란 개념이 왜 필요할까?**
- **viewDidLoad()** (앱의 화면에 들어오면, 가장 먼저 실행시키는 함수)
- **내부적인 메커니즘** (운영체제에 의해서, 자동으로 호출되는 함수들이 있음)
- 앱의 실행중 화면이 감춰졌다가(다음 화면으로 넘어갔다가), 화면이 다시 보이기도 함
- **(화면의 전환) 해당 시점에 호출되는 함수들이 있음**
- **예시)** 다음 화면으로 갔다가 다시 돌아오면, (변경사항 업데이트를 위해) 서버에서 데이터를 다시 받아와야 할 수도 있음)

ViewController 의 View를 개발자가 직접 만든 View로 바꾸고 싶을 때 (코드로 뷰를 짠다면)


override func loadView() {
	//super.loadView()는 하면 안됨
	view = loginView()
}


2) 앱의 생명 주기

- 앱의 생명주기란 개념이 왜 필요할까?
- 아이폰 앱 게임 중 → 전화 옴 → 앱은 자동으로 “통화화면으로” 전환 (실행중이던 앱은? 잠시 비활성화 상태로)
- 게임 중이던 모든 데이터는?

3) Drawing 주기

- 1초에 60번 화면을 다시 그럼 (Drawing Cycle) 항상은 아니고, 필요한 경우)
- (오토레이아웃/그림을 다시 그려야 하는) 해당 시접에 호출되는 함수들이 있음
- 애니메이션(어떤 오브젝트가 이동하는)과 같은 효과, 또는 스크롤과 같이 화면이 이동할때는 내부적으로 1초에 60번 특정 함수들을 호출하면서 그림을 다시 그림
- 적절한 시점에 오토레이아웃 변경/레이아웃(위치,크기) 변경 / 그림 다시 그리기 위해서, 호출해줘야 하는 함수들이 있음

앱의 생명주기 → 앱의 비활성화 /  다른앰으로 또는 백그라운드로 전환 / 종료 시점을 파악하기 위함

뷰컨트롤러의 생명주기 → 하나의 앱에서 화면전환 시점을 파악하기 위함

Drawing 주기 → 하나의 화면에서, (애니메이션이라던지) 다시 그리는 시점을 파악하기 위함

시점의 파악 → 이미 애플이 잘 구현해 놓았고, 내부 메커니즘에 의해 함수들을 (자동으로) 호출 (해당 올바른 시점의 함수들을 재정의해서 필요한 내용들을 구현하기만 하면 됨)
